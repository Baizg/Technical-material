4G虚拟内存空间布局  (博客地址：https://blog.csdn.net/Dthinking/article/details/86309863)

进程地址空间需要隔离，防止恶意的程序修改其他程序的内存数据，因此计算机中引入虚拟地址空间。

4GB虚拟地址空间布局如下图所示 (无法贴图，见博客地址)

 
 

 每个程序运行起来以后，它将拥有自己独立的虚拟地址空间。所有的进程都拥有自己的用户空间，但却共享一个内核空间。

用户空间：

1、128M大小的不可访问区域（保留区）不可读、不可写

      我们通常将申请的临时变量指针初始化时置为NULL，可以防止后续无意使用这个指针时出错，NULL=0X00，而保留区的数据不能访问。

2、.text代码段

       存储代码中的指令。一份代码是由数据和指令构成的，局部变量也属于指令，但是局部变量存储在栈上，代码运行时才在栈中预留好的区域中开辟

3、.data段

      这个区域存储代码中的各种数据，包括全局变量，静态局部变量。且必须为已经初始化且初始化不为0的数据

4、.bss段

     这个区域存储的也是代码中的各种数据，和.data不同的是，存储的是未初始化或者初始化了但为0 的数据（这个段在可执行文件中不占用空间）

5、堆

     当我们需要申请一块连续且指定大小的内存块的动态内存时，需要在 堆中申请。并且需要手动申请，手动释放。不释放会造成内存泄漏

6、栈

    所有的局部变量存储在这里，函数的运行也需要栈的开辟，释放空间由系统完成

7、命令行参数

main()函数原型：int main(int argc,char *argv[],char *envp[]){}

argc是命令行参数的个数，不指定时默认为1，是当前文件名。 char *argv[]也可以写成char**argv,其中argv[0]默认存放程序名称，argc的值最小为1.char *envp[]是环境变量。    命令行参数就是argv，里面存放程序名，以及参数。

内核空间：

1、内存直接访问区（ZONE_DMA 大约16M）

ZONE_DirectMemoryAccess(直接内存访问)可以加快磁盘和内存之间的数据交换，不需要经过CPU的寄存器，这是CPU可以去干别的事，大大增加了效率。

2、ZONE_NORMAL（大约892M）

   内核中最重要最常用的部分，用于直接映射，PCB就在这里。

3、ZONE_HIGHMEM(128M)

   高端内存，用于在内核中映射高于1GB的物理内存时使用，64位操作系统没有该段
